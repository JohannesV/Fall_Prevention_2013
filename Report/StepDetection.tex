\chapter{Step Detection Algorithm}

\section{Development Process}
As the group had little experience in sensor use and signal processing, a series of experiments were conducted to better understand which sensors provide useful information for step detection, and which patterns predicate steps. To this end, a simple app was developed to observe sensor input and store the raw data as a file, which then could be transferred to a computer. A set of python scripts were written to plot  the data time series. Using python, the group experimented with different step detection algorithms, and a prototype was developed. Finally, the algorithm was implemented in the Valens Step Detector app, modified to work with live data.

\section{The Algorithm}
The current section will explain the algorithm used for step detection, formulated as an off-line algorithm. The following section will explain what changes was made to make the algorithm work for live data streams.

Experiments showed that the accelerometer consistently gave the most predicative feedback patterns for step detection\footnote{None of the android phones available to the group at the time had a working gyroscope. It is suspected that a gyroscope can replace or supplement the accelerometer for more precise step detection, but this should tested empirically.}. Furthermore, it was found that the total acceleration was a better predicator of steps than acceleration along any of the single axes individually. To exploit this, a pre-processing step calculates the a vector length in euclidian space of the raw acceleration vector.

Detecting steps based on a time series of accelation vector lengths reduces to peak detection in the time series graph. The step detection algorithm is therefore essentially a generic algorithm for peak detection in noisy data. The noise in the data originates from noise in the sensor readings. To cope with the noise, the data is first smoothed using a moving average\footnote{That is, every datapoint has its value set to the average of itself and the x neighbours before and after it, where x is called the \emph{window size} of the smoothing.}.

Subsequently the program runs the main peak detection algorithm, which consists of the following steps:
\begin{description}
\item[Calculate peak strength] \hfill \\
Every data point in the time series has its \emph{peak strength} calculated. The peak strength for a point $x_{i}$ is calculated as $\frac{(x_{i} - x_{i-1} + x_{i} - x_{i-1} + \ldots + x_{i} - x_{i-k})}{k}$
\end{description}

SKRIV OM KORLEIS EIN FINN VERDIANE SOM WINDOW\_SIZE etc. 
a\chapter{Step Detection Algorithm}

\section{Development Process}
As the group had little experience in sensor use and signal processing, a series of experiments were conducted to better understand which sensors provide useful information for step detection, and which patterns predicate steps. To this end, a simple app was developed to observe sensor input and store the raw data as a file, which then could be transferred to a computer. A set of python scripts were written to plot  the data time series. Using python, the group experimented with different step detection algorithms, and a prototype was developed. Finally, the algorithm was implemented in the Valens Step Detector app, modified to work with live data.

\section{The Algorithm}
The current section will explain the algorithm used for step detection, formulated as an off-line algorithm. The following section will explain what changes was made to make the algorithm work for live data streams.

Experiments showed that the accelerometer consistently gave the most predicative feedback patterns for step detection\footnote{None of the android phones available to the group at the time had a working gyroscope. It is suspected that a gyroscope can replace or supplement the accelerometer for more precise step detection, but this should tested empirically.}. Furthermore, it was found that the total acceleration was a better predicator of steps than acceleration along any of the single axes individually. To exploit this, a pre-processing step calculates the a vector length in euclidean space of the raw acceleration vector.

Detecting steps based on a time series of acceleration vector lengths reduces to peak detection in the time series graph. The step detection algorithm is therefore essentially a generic algorithm for peak detection in noisy data. The noise in the data originates from noise in the sensor readings. To cope with the noise, the data is first smoothed using a moving average\footnote{That is, every data point has its value set to the average of itself and the x neighbours before and after it, where x is called the \emph{window size} of the smoothing.}.

Subsequently the program runs the main peak detection algorithm, which consists of the following steps:
\begin{description}

\item[Calculate peak strength] \hfill \\
Every data point in the time series has its \emph{peak strength} calculated. Informally, the peak strength of a data point is a measurement of how much that point is worthy of being considered a peak. A wide range of functions can map the raw vector lengths into a peak strength graph, but an additional desideratum of the peak strength function is that the output values should be normalized around 0, where only actual potential peaks are given sub-zero values. The peak strength for a point $x_i$ is calculated as $\frac{\frac{(x_{i} - x_{i-1} + x_{i} - x_{i-1} + \ldots + x_{i} - x_{i-k})}{k} + \frac{(x_{i} - x_{i+1} + x_{i} - x_{i+1} + \ldots + x_{i} - x_{i+k})}{k}}{2}$, where k is a constant referred to as the \emph{peak strength window}.

\item[]

\end{description}

SKRIV OM KORLEIS EIN FINN VERDIANE SOM WINDOW\_SIZE etc. 

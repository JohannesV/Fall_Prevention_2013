\chapter{Testing}
This chapter only touches the surface of general software testing, while focusing on methods, types and levels used in this project.
\section{Levels, methods and types}
Software testing is generally broken down into several levels, methods and types. This section will introduce general testing terminology.
\subsection{Levels}
Software testing has four levels that correspond to how far into the software development process the team has come. The first three test levels refer to the development process and the last level refers to completion, or after development.
\begin{enumerate}
\item Unit testing is the first level where all individual components, such as functions, are tested. Often these tests are done by inputting sample data and validating output.
\item Inspections refers to a peer review or code review process where a team of individuals read through the source code to reveal early and obvious bugs. An error or bug that is not very visible for the developer may be very visible to an inspector, as a single developer working on a block of code can often get "blind". Empirical studies have shown that inspections are very efficient in weeding out bugs, reporting that between 60 and 90 \% of all bugs can be found using code inspections\footnote{Sommerville, p209\cite{sommerville}}
\item Integration testing is the next step which takes groups of individual units to verify that they work together as a component, or to reveal faults in the integration.
\item System testing is the last step of test in the development process where the complete software system is tested to evaluate whether the components integrate as expected to form a complete system.
\item Acceptance testing is the last and highest level of testing where the system or software is tested to verify that it is acceptable for delivery. The test itself is usually Black Box Tests (see Section \ref{def:blackboxtesting}) to see if the customer will receive the desired and expected results.
\end{enumerate}
\subsection{Methods}
The approach to software testing is called methods or techniques. Primarily there are two methods when testing software; black box testing, and white box testing.
\begin{itemize}
\item \label{def:blackboxtesting} Black Box Testing is named so because the internals of the software or system is not visible to the tester, like inside a dark black box. The tests are usually functional tests to reveal interface problems, functionality flaws, performance troubles, behavior errors and incorrect or missing functions. This test method is usually done by independent testers with no programming or implementation knowledge. Mainly these test method is applicable at a higher level of testing; System testing and Acceptance testing.
\item White Box Testing is a test method where the internals of a software or system is known to the tester, who usually is a programmer. Programming and implementation knowledge is required in this method since this method studies the code and goes way beyond the interface visible to the end user. The method is mainly applicable in lower levels of testing like Unit testing and Integration testing, but it is mostly used in Unit testing. The overall advantage of this test method is that testing can be started on in an earlier stage to make sure every bit of program produces correct output given an input and gives the opportunity to quickly correct problems.
\end{itemize}
\subsection{Types}
Only some of the test types are mentioned in this chapter, though there are many different testing types not used in this process and therefore not covered.
\begin{itemize}
\item Smoke Testing, only tests major functions of a software or system to decide if it further testing should proceed. If the Smoke Tests fail, no further testing is necessary due to deeper testing will fail. A kind of Smoke Test could be to check if the software compiles and starts up. Smoke Tests should under no circumstance replace Functional or Regression Testing.
\item Functional Testing, verifies if the software or system to have met its requirements or specifications. In functional testing, Black Box Testing is performed where the tester has no aspect of what is going on internally. See above explanation about Black Box Testing for more. When performing Functional Testing a set of inputs and expected outputs are matched up to one another, where they do not match the test fails. When performing this type of testing it is easy to miss logical errors due to the fact that the tester do not know what is going on underneath the code.
\item Regression Testing, essentially re-tests previously verified tests to ensure that bug fixes, enhancements or optimization has not affected the system or software after a given change in code. The test type can be performed on any level, but is mostly relevant on the System Testing level when the bug fixing, optimization and enhancements are done. Many companies choose to automate these tests to save time and money when software or systems has changed.
\end{itemize}
\section{Plans and process}
This section outlines the testing plans for the project.
\subsection{Unit testing}
As stated in the chapter on software development (section \ref{def:devProcess}), automated unit testing was not performed due to the group's unfamiliarity with unit testing framework. Unit testing was therefore not conducted in a rigorous manner. Instead, unit testing was performed by forcing the relevant method to be called with simulated input, and manually verifying the output. Unit testing was only deemed necessary on slightly complex method, while inspections and integration tests were deemed to be sufficient for the more basic methods.
\subsection{Inspections}
Inspections were performed thoroughly throughout the project, and constituted the main form of quality assurance in the early stages of development. In addition to the sanctioned habit of the coder always inspecting his own code, team members regularly inspected other members' code to identify errors or weaknesses. For the more complex methods - which were always developed using pair programming - the second coder in the pair functioned as a reviewer.
\subsection{Integration testing}
The integration testing was done for every application separately. This was done, in theory, by simply running the application component by itself and checking that the outcome of every run corresponded to the expectations. However, only the content provider and the demo application were given completely isolated integration tests. The other two applications - the data feeder and the step detector - were tested in conjunction with the content provider, as their interfaces to the content provider were so simple that they did not interfere with the testers' abilities to evaluate the component's performance by itself.
\subsection{System testing}
System testing was performed by trying to run the applications and checking that the data flow between the applications worked as expected. In this stage a form of smoke testing were used by checking if the data storage increased (data being saved to the phone) and by checking the output in the GUI app (statistics screen showing data). After the initial smoke testing, the entire system was given a test run over several days, to test the system's performance in a close-to-real setting. 

\subsection{Acceptance testing}
\label{def:accTesting}
At the During the end of the project, the customer expressed a desire to do acceptance testing for the application on a group of test subjects. To facilitate access to a demo version of the software for the test group, the application was deployed on a web site \footnote{\url{http://valens.brennhe.it/}} along with instructions for installation and a form to give feedback. Unfortunately, the customer was unable to gather test volunteers within the time limit constraints of the project, so the only results were generated by the customer representative himself. 

The acceptance test conclusion was that the user-related aspects of the application system, such as stability, power consumption and easy of set-up were good, but there were problems stemming from the back-end functions, leading to inconsistencies in step counts for the same day and different feedback for the widget and the main app. For the full acceptance test report, see Appendix \ref{appendix:testResults}.

\input{Testdata}
